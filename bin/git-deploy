#!/usr/bin/env node

/**
 * Deployment script for the REST API in NorgesGruppen
 *
 * Executable will be available on the path by executing `npm install ng-rest-deploy -g`.
 * If installed as a dependency the binary will be placed in node_modules/.bin/ng-rest-deploy
 */

var colors = require('colors'),// changes String.prototype
    prompt = require('prompt'),
    util = require('util'),
    winston = require('winston'),
    Promise = require('es6-promise').Promise,
    promisify = require('promisify-node'),
    exec = promisify(require('child_process').exec),
    spawn = require('child_process').spawn,
    fse = promisify(require('fs-extra')),
    mktemp = promisify(require('mktemp')),
    nodegit = require('nodegit'),
    path = require('path'),
    program = require('commander'),
    pkg = require(path.join(__dirname + '/..', 'package.json')),
    lib = require('../lib'),
    config = lib.config,
    logger = new (winston.Logger)({
        transports: [
            new (winston.transports.Console)({level: 'debug'})
        ]
    }),
    available_envs,
    environmentConfig,
    tmpDir;


config.load('./deploy.conf');
available_envs = Object.keys(config.environment),

//console.log(util.inspect(pkg));
//console.log(util.inspect(config));
//console.log(available_envs)
//process.exit(1);

    /* Parse command line options
     * the options will be available as properties on the program variable
     */
    program
        .version(pkg.version)
        .option('-e, --environment <env>', 'Available environments: ' + available_envs.join(' | '), function (env) {
            if (!(env in config.environment)) {
                console.log('Unknown deployment environment: ', env);
                process.exit(1);
            }
            environmentConfig = config.environment[env];
        })
        .option('-l, --local', 'will use the current directory as the git repo to use (default: GitHub)')
        .option('-f, --force', 'will not prompt for confirmation. Required for non-interactive shells')
        .option('-c, --commit <tree-ish>', 'Use the specified commit/tag/branch [default is environment specific]')
        .parse(process.argv);


// Could not get nodekit to work for cloning repos.
// Therefore using git directly
// @see https://github.com/nodegit/nodegit/issues/372
function cloneRemoteRepoToTemporaryFolder(tmpFolder) {
    var repoUrl = config.src_repo;
    var execString = util.format('git clone %s %s', repoUrl, tmpFolder);

    logger.debug('Executing "' + execString + '"');

    return exec(execString);
}

function cloneLocalRepoToTempFolder(tmpFolder) {
    return exec('git clone --local file://' + tmpFolder)
}

function checkout(treeish, opts) {
    return exec('git checkout ' + treeish, opts);
}

//console.log('local: ' + program.local)
//process.exit(1);

/*
 *  start as a CLI program if run directly from node
 **/
if (require.main === module) {
    if (!program.environment) {
        program.help();
    }

    logger.debug('Creating  temporary directory');
    mktemp.createDir('.tmpXXXXXXX')
        .then(function (path) {
            tmpDir = path;

            if (program.local) {
                logger.debug('Clonging local Git directory');
                return cloneLocalRepoToTempFolder(path);
            } else {
                return cloneRemoteRepoToTemporaryFolder(path);
            }
        })
        .then(function () {
            var treeish = program.commit || environmentConfig.src.branch;
            logger.debug('Checking out ' + treeish);
            return checkout(treeish, {cwd: tmpDir});
        })
        .then(function () {
            logger.debug('Opening repo ' + tmpDir);
            return nodegit.Repository.open(tmpDir);
        })
        .then(function (repoRes) {
            return Promise.all(
                [
                    repoRes.getHeadCommit()
                    ,
                    new Promise(function (resolve, reject) {
                        repoRes.getRemote(config.remote_name, function (err, remote) {
                            if (err) {
                                logger.error(err.message);
                                logger.info('Adding remote for push');

                                // adding

                                resolve();
                            } else {
                                logger.debug('Existing remote with that name'+ remotes);
                                resolve();
                            }
                        });
                    })
                ])
        })
        .then(function (vals) {
            return vals[0];
        })
        .then(function (commit) {
            console.log('HEAD commit is ', commit.sha());
            console.log('Author:', commit.author().name() + ' <' + commit.author().email() + '>');
            console.log('Date:', commit.date());
            console.log('\n    ' + commit.message());
        })
        .then(function () {
            // push to remote repo
            //exec('git push -f azure')
            //spawn('git', [], { stdio: 'inherit' });

        })
        .then(function () {
            if (tmpDir) {
                logger.info('Removing temporary directory');
                return fse.remove(tmpDir);
            }
        })
        .catch(function (err) {
            logger.error(err);
            logger.error("Got error: ", err.message);
        });
}

